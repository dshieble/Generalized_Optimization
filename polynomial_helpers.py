import matplotlib.pyplot as plt
import numpy as np
from numpy.polynomial import Polynomial
import sympy
from functools import reduce
from scipy.spatial.distance import cosine
from tqdm import tqdm
import helpers
from sympy.solvers.solveset import linsolve
from sympy.printing.latex import LatexPrinter, print_latex


def get_dynamical_system_equation(t, a_dict, dP):
    """
    Returns the s(t+1) = s(t) + dl/dx(s(t)) equation that we implicitly set equal to 0. This is the equation that enforces that the integer polynomial s passes through the trajectory of integer gradient descent
        t: integer
        a_dict: dictionary {index: sympy variable}
        dP: linear function
    
    This returns the following expression, which we interpret as being set equal to 0
        a0(1 - 1 - dP(1)) + a1((t+1) - t - dP(t)) + a2((t+1)^2 - t^2 - dP(t^2)) + ... + an((t+1)^n - t^n - dP(t^n))
    """
    out = 0
    for i in range(len(a_dict)):
        out += a_dict[i]*(((t + 1)**i) - (t**i) + dP(t**i))
    return out


def get_dldx_dsdt_equation(t, a_dict, dP):
    """
    Returns the dl/dx(s(t)) = ds/dx(t) equation that we implicitly set equal to 0. This is the equation that enforces that at t the derivative of the integer polynomial ds/dx(t) is equal to the gradient of the loss dl/dx(s(t))
        t: integer
        a_dict: dictionary {index: sympy variable}
        dP: linear function
    
    This returns the following expression, which we interpret as being set equal to 0
        (dP(a0) + a1) + (dP(a1) + 2*a2)*t + (dP(a2) + 3*a3)*(t**2) + (dP(a3) + 4*a4)*(t**3) + dP(a4)*(t**4)
    """
    out = 0
    for i in range(len(a_dict) - 1):
        out += (dP(a_dict[i]) + (i+1)*a_dict[i+1])*(t**i)
    out += dP(a_dict[len(a_dict) - 1]*(t**(len(a_dict) - 1)))
#     out += dP(2*a_dict[len(a_dict) - 1]*(t**(len(a_dict) - 1)))
    return out


def evaluate_s(t_value, a_dict):
    """
    Evaluate the polynomial s 
        t_value: a single number or sympy variable
        a_dict: a dictionary {index: number or sympy variable}
    """
    out = 0
    for i in range(len(a_dict)):
        m = 1
        for j in range(i):
            m = m*t_value
        out += a_dict[i]*m
    return out


def find_starting_value(equations, a_dict, raw_starting_value):
    """
    Given an underspecified set of equations with no starting value and a proposal starting value,
      find a new starting value that the proposal value divides and that yields an integer solution
    """
    equations_with_raw_start = equations + [a_dict[0] - raw_starting_value]
    raw_solution_values = list(linsolve(equations_with_raw_start, a_dict.values()))[0]
    raw_rational_solution_dict = {a_var: value for a_var, value in zip(a_dict.values(), raw_solution_values)} 
    raw_denominator_lcm = np.lcm.reduce([s.q for s in raw_rational_solution_dict.values()])
    return raw_starting_value * raw_denominator_lcm


def choose_solution(underspecified_solution_values):
    # Replace all of the variable terms in a list of sympy expressions with 1
    symbol_dict = {
        x:sympy.Rational(np.random.randint(-10, 10))
        for x in underspecified_solution_values if isinstance(x, sympy.core.symbol.Symbol)}
    print(symbol_dict)
    solution_values = []
    for x in list(underspecified_solution_values):
        if isinstance(x, sympy.core.numbers.Number):
            solution_values.append(x)
        elif isinstance(x, sympy.core.symbol.Symbol):
            solution_values.append(symbol_dict[x])
        else:
            solution_values.append(x.as_poly().eval(symbol_dict))
    return solution_values


def get_solution_dict(equations, a_dict):
    """
    Solve the system of diophantine equations by solving the linear system and upscaling the solution
        equations: A system of equations
        a_dict: a dictionary {index: number or sympy variable}
    """
    underspecified_solution_values = list(linsolve(equations, a_dict.values()))[0]
    raw_rational_solution_values = choose_solution(underspecified_solution_values=underspecified_solution_values)
    raw_rational_solution_dict = {a_var: value for a_var, value in zip(a_dict.values(), raw_rational_solution_values)} 
    
    raw_denominator_lcm = np.lcm.reduce([s.q for s in raw_rational_solution_dict.values()])

    solution_values = [value*raw_denominator_lcm for value in raw_rational_solution_values]
    solution_dict = {a_var: value for a_var, value in zip(a_dict.values(), solution_values)} 

    # Verify the solution
    for equation in equations:
        poly = equation.as_poly()
        
        # Verify solution generated by solver
        assert poly.eval({k: raw_rational_solution_dict[k] for k in poly.gens}) == 0, equation
        assert poly.eval({k: solution_dict[k] for k in poly.gens}) == 0, equation

    # Verify that the solution values are integers
    for s in solution_values:
        assert s.q == 1, solution_values
    
    return solution_dict

